<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Product Designer Type & Skill Diagnostic</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Jost:wght@400;500;700;900&display=swap" rel="stylesheet">
  
  <style>
    /* ▼▼▼【カスタマイズエリア】色設定 ▼▼▼ */
    :root{
      /* ベースカラー */
      --bg:#f3f4f6;       /* 全体の背景（薄いグレー） */
      --surface:#ffffff;  /* カードの背景（白） */
      --text:#111827;     /* 文字色（黒に近いグレー） */
      --muted:#6b7280;    /* 薄い文字色 */
      --line:#e5e7eb;     /* 線の色 */
      
      /* アクセントカラー（オレンジ） */
      --acc:#f97316;
      --accSoft:#fff7ed;
      --accHover:#ea580c;
      
      /* その他 */
      --danger:#dc2626;   /* 赤 */
      --success:#1e3a8a;  /* ネイビー */

      /* 形状 */
      --radius:24px;
      --radius-sm:14px;
      
      /* 影 */
      --shadow-card: 0 4px 20px -2px rgba(0, 0, 0, 0.08), 0 2px 6px -2px rgba(0, 0, 0, 0.04);
    }
    /* ▲▲▲ 設定ここまで ▲▲▲ */

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:"Noto Sans JP", sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{ max-width:1060px; margin:0 auto; padding:18px 14px 40px; }
    h1{ margin:0 0 6px; font-size:24px; letter-spacing:-.2px; font-family: "Jost", "Noto Sans JP", sans-serif; font-weight: 600;}
    h2{ margin:0 0 10px; font-size:18px; letter-spacing:-.1px; }
    h3{ margin:0; font-size:14px; letter-spacing:-.1px; }
    p{ margin:8px 0 14px; color:var(--muted); line-height:1.65; }
    .small{ font-size:12px; color:var(--muted); }

    /* Layout */
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:24px; }
    @media (max-width:920px){ .grid2{ grid-template-columns:1fr; } }
    .row{ display:flex; gap:12px; flex-wrap:wrap; }
    .vertical-stack{ display:flex; flex-direction:column; gap:24px; max-width:600px; margin:0 auto; }

    /* Surfaces */
    /* .header-info はここから除外して個別に定義 */
    .surface, .screen, .result-card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 24px;
      border: none;
      box-shadow: var(--shadow-card);
    }
    
    /* 修正：ヘッダー情報を座布団なし・左揃えに変更 */
    .header-info {
      padding: 4px 0 16px 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
      background: transparent;
      border: none;
      box-shadow: none;
      text-align: left;
    }

    .result-card { height: 100%; min-width: 0; }

    .rule{ height:1px; background:var(--line); margin:18px 0; }
    .rule.soft{ background:#f3f4f6; }

    /* Clickable Items */
    .tap{
      width:100%;
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:14px 14px;
      border-radius:var(--radius-sm);
      border:1.5px solid #d1d5db;
      background:#ffffff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.03);
      cursor:pointer; user-select:none;
      transition: all .2s ease;
    }
    .tap:hover{ background-color: var(--accSoft); border-color: var(--acc); transform: translateY(-1px); }
    .tap.selected{ border-color: var(--acc); background: var(--accSoft); box-shadow: 0 4px 14px rgba(249, 115, 22, 0.15); }
    .tap.selected .chev{ background:#ffffff; border-color: rgba(249, 115, 22, 0.35); color: var(--acc); }
    .tap .chev{
      flex:0 0 auto; width:30px; height:30px; border-radius:999px;
      display:grid; place-items:center; background:#f9fafb;
      border:1px solid var(--line); color:#374151; font-weight:900;
    }
    .tap.neutral:hover{ background-color: var(--accSoft); border-color: var(--acc); }

    /* Buttons */
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px; padding:12px 18px; border-radius:12px;
      border:1px solid var(--line); background:#fff; color:var(--text);
      font-weight:700; cursor:pointer; min-height:48px; transition: all .2s;
    }
    .btn:hover{ background:#f9fafb; }
    .btn:active{ transform: translateY(1px); }
    
    .btn.primary{ border-color:transparent; background:var(--acc); color:#fff; box-shadow: 0 4px 12px rgba(249, 115, 22, 0.25); }
    .btn.primary:hover{ background:var(--accHover); }
    .btn.primary:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; background:var(--muted); }
    
    .btn.orange-outline{
      border: 1.5px solid var(--acc);
      color: var(--acc);
      background: #fff;
    }
    .btn.orange-outline:hover{ background: var(--accSoft); }
    .btn.orange-outline:disabled{ border-color:var(--line); color:var(--muted); background:#f9fafb; opacity:1; }

    .btn.danger{ color:var(--danger); background:#fff; border-color: rgba(220,38,38,.25); }
    .btn.danger-outline{ color:var(--danger); background:#fff; border: 1.5px solid var(--danger); font-weight: 700; }
    .btn.danger-outline:hover{ background:#fef2f2; }

    /* Components */
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--line); border-radius:999px; color:var(--muted); background:#fff; }
    .progress{ height:10px; background:#eef2f7; border-radius:999px; overflow:hidden; }
    .bar{ height:100%; width:0%; background:var(--acc); transition: width 0.3s ease; }
    
    input[type="text"]{
      width:100%; padding:14px 12px; border-radius:12px;
      border:1px solid var(--line); outline:none; font-weight:650; color:var(--text); background:#fff;
    }
    input[type="text"]:focus{ border-color: var(--acc); box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.1); }

    /* Accordion */
    details{ border:1px solid var(--line); border-radius:12px; background:#fff; padding:10px 12px; }
    summary{ cursor:pointer; font-weight:700; list-style:none; display:flex; align-items:center; justify-content:space-between; padding:6px 4px; user-select:none; }
    summary::-webkit-details-marker{ display:none; }
    .chk{ display:flex; gap:10px; align-items:flex-start; padding:10px 4px; border-top:1px solid var(--line2); cursor: pointer; }
    .chk:hover{ background: #f9fafb; }
    input[type="checkbox"]{ margin-top:3px; transform:scale(1.15); cursor: pointer; accent-color: var(--acc); }

    .hidden{ display:none !important; }
    
    /* Result Specifics */
    .mapBox{ border:1px solid var(--line); border-radius:12px; background:#fff; padding:12px; }
    .result-section-title { font-size: 16px; font-weight: 700; margin-bottom: 12px; display: flex; align-items: center; gap:8px; color:var(--acc); }
    .result-section-header { background:#f3f4f6; padding:10px 14px; border-radius:8px; margin-bottom:16px; font-weight:bold; text-align:center; }
    
    .skill-category-label {
      font-size: 12px; font-weight: 900; color: var(--muted); letter-spacing: 0.05em; text-transform: uppercase;
      margin: 20px 0 8px; border-bottom: 1px solid var(--line); padding-bottom: 4px;
    }
    .skill-desc { font-size: 11px; color: var(--muted); line-height: 1.5; margin-top: 4px; }

    .type-display-main { font-size: 24px; font-weight: 900; color: var(--acc); line-height: 1.3; }
    .type-display-sub { font-size: 15px; font-weight: 700; color: var(--text); line-height: 1.4; }
    .type-label-tag { font-size: 11px; color: var(--muted); margin-bottom: 2px; }

    /* タイプ説明の背景（CSSで固定） */
    #typeDesc {
      white-space: pre-wrap;
      background: #f3f4f6;
      padding: 12px;
      border-radius: 12px;
      color: var(--text);
      font-size: 12px;
      line-height: 1.6;
    }
  </style>
</head>

<body>
<div class="wrap">
  <h1>Product Designer Type & Skill Diagnostic (Ver.0.3)</h1>
  
  <div class="header-info">
    <div style="font-weight:700; margin-bottom:4px;">診断概要</div>
    <div>タイプ：メイン（属性）＋サブ ／ 能力：7軸（GATE）、表示：平均＋メインタイプ典型値</div>
    <div style="margin-top:6px;">※優劣判定ではありません。配置・育成・対話の材料として使用してください。</div>
  </div>

  <div class="rule soft"></div>

  <section id="view-home" class="surface">
    <h2>1) モード選択</h2>
    
    <div class="vertical-stack">
      <div>
        <h3>① 評価モードを選ぶ（必須）</h3>
        <div class="row" style="flex-direction:column; margin-top:10px;">
          <div class="tap" role="button" tabindex="0" data-mode="self" id="modeSelf">
            <div class="left">
              <div class="title">自己評価（Self）</div>
            </div>
            <div class="chev">›</div>
          </div>

          <div class="tap" role="button" tabindex="0" data-mode="other" id="modeOther">
            <div class="left">
              <div class="title">客観評価（Objective）</div>
            </div>
            <div class="chev">›</div>
          </div>
        </div>
      </div>

      <div>
        <h3>② 評価スコープを決める（任意）</h3>
        <div style="margin-top:10px">
          <input id="scopeText" type="text" placeholder="例：直近1年 / 今回PJ など" />
        </div>
      </div>

      <div style="margin-top:20px;">
        <h3>スタート（コース選択）</h3>
        <div class="grid2" style="margin-top:10px; gap:12px;">
          <button id="btnStart" class="btn primary" style="width:100%; flex-direction:column; padding:18px;" disabled>
            <span style="font-size:16px;">総合診断スタート</span>
            <span style="font-size:11px; font-weight:normal; opacity:0.9;">タイプ診断 ＋ 能力判定</span>
          </button>
          
          <button id="btnSkip" class="btn orange-outline" style="width:100%; flex-direction:column; padding:18px;" disabled>
            <span style="font-size:16px;">能力判定のみ</span>
            <span style="font-size:11px; font-weight:normal;">タイプ診断をスキップ</span>
          </button>
        </div>
      </div>
    </div>
  </section>

  <section id="view-type" class="screen hidden">
    <h2>2) タイプ判定</h2>
    <div id="typeModeDisplay" style="font-weight:900; color:var(--acc); font-size:16px; margin-bottom:8px;"></div>

    <div class="row" style="justify-content:space-between; align-items:center">
      <div class="pill"><span id="modeBadge">mode</span><span class="small">｜</span><span id="qCounter">0/24</span></div>
    </div>

    <div style="margin-top:10px" class="progress"><div id="qBar" class="bar"></div></div>

    <div class="rule"></div>

    <div>
      <div class="small" id="qIdText">Q</div>
      <div id="qText" style="margin-top:6px; font-size:20px; font-weight:950; letter-spacing:-.2px">...</div>
      <div class="rule"></div>

      <div id="selfChoices" class="row hidden" style="flex-direction:column"></div>
      <div id="otherChoices" class="row hidden" style="flex-direction:column"></div>

      <div class="rule"></div>

      <div class="row">
        <button id="btnTypeBack" class="btn">戻る</button>
        <button id="btnTypeReset" class="btn danger">最初に戻る</button>
      </div>
    </div>
  </section>

  <section id="view-skill" class="screen hidden">
    <h2>3) 能力判定（7軸・GATE）</h2>
    <div style="margin-bottom:16px;">
      <div id="skillModeDisplay" style="font-weight:900; color:var(--acc); font-size:16px; margin-bottom:4px;"></div>
      <p style="margin:0; font-size:13px; color:var(--muted);">該当する項目にチェックしてください（順不同）。</p>
    </div>

    <div class="grid2" id="skillAccordions"></div>

    <div class="rule"></div>

    <div class="row">
      <button id="btnSkillBack" class="btn">戻る</button>
      <button id="btnToResult" class="btn primary">結果を見る</button>
    </div>
  </section>

  <section id="view-result" class="hidden">
    
    <div id="captureArea" style="background:var(--bg); padding:0;">
      
      <div class="surface" style="margin-bottom:20px; position:relative;">
        <div style="margin-top:20px;">
          <h2>4) 診断結果</h2>
          <div class="pill">
            <span id="resultMode">—</span>
            <span class="small">｜</span>
            <span id="resultScope" class="small">—</span>
          </div>
        </div>
      </div>

      <div class="grid2">
        <div class="result-card" id="typeResultCard">
          <div class="result-section-header">タイプ診断結果</div>
          
          <div id="typeResultContent">
            <div style="background:var(--accSoft); padding:16px; border-radius:12px; border:1px solid rgba(249,115,22,0.1);">
               <div class="type-label-tag">メインタイプ</div>
               <div id="mainTypeText" class="type-display-main">—</div>
            </div>

            <div style="margin-top:12px; padding:12px; border-radius:12px; border:1px solid var(--line); background:#fff;">
               <div class="type-label-tag">サブタイプ</div>
               <div id="subTypeText" class="type-display-sub">—</div>
            </div>

            <div class="rule soft"></div>

            <div class="result-section-title">タイプマップ</div>
            <div id="typeMapWrap" class="mapBox">—</div>

            <div class="rule soft"></div>

            <div class="result-section-title">説明</div>
            <div id="typeDesc" class="small">—</div>
          </div>
          
          <div id="typeResultSkipped" class="hidden" style="text-align:center; padding:40px 0; color:var(--muted);">
            タイプ診断はスキップされました
          </div>
        </div>

        <div class="result-card">
          <div class="result-section-header">能力診断結果</div>

          <div class="result-section-title">能力詳細（Lv / 差分）</div>
          <div id="skillList" style="margin-bottom:20px;"></div>

          <div class="rule soft"></div>
          
          <div class="result-section-title">能力レーダーチャート</div>
          <div class="small" style="margin-bottom:8px;">実測（橙太線）／ 平均Lv3（グレー線）<span id="radarTypicalLabel"> ／ メインタイプ典型（青点線）</span></div>
          <div style="position: relative; width: 100%; min-height:300px;">
             <canvas id="radar"></canvas>
          </div>
        </div>
      </div>

      <div class="small" style="text-align:right; margin-top:20px;">Product Designer Type & Skill Diagnostic v0.3</div>
    </div> 
    
    <div class="surface" style="margin-top:20px;">
      <div class="row" style="justify-content: space-between; align-items: flex-end;">
        <div style="display:flex; gap:10px;">
          <button id="btnResultBack" class="btn">能力判定へ戻る</button>
          <button id="btnRestart" class="btn danger-outline">最初に戻る</button>
        </div>
        
        <div style="display:flex; gap:10px; align-items:center;">
          <span class="small">書き出し：</span>
          <button id="btnExportCSV" class="btn">CSV保存</button>
          <button id="btnExportPNG" class="btn">画像保存(PNG)</button>
        </div>
      </div>
    </div>

  </section>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

<script>
/* =========================
   DATA DEFINITIONS
========================= */
const TYPES = [
  { id:"yanki_aniki", label:"兄貴肌ヤンキー" },
  { id:"yanki_ubu", label:"うぶなヤンキー" },
  { id:"otaku_you", label:"陽キャオタク" },
  { id:"otaku_in", label:"陰キャオタク" },
  { id:"shokunin_flexible", label:"柔軟な職人" },
  { id:"shokunin_stubborn", label:"頑固な職人" },
  { id:"artist_open", label:"ひらけたアーティスト" },
  { id:"artist_mystery", label:"不思議アーティスト" }
];

const RELATED_TYPES = {
  yanki_aniki: "yanki_ubu", yanki_ubu: "yanki_aniki",
  otaku_you: "otaku_in", otaku_in: "otaku_you",
  shokunin_flexible: "shokunin_stubborn", shokunin_stubborn: "shokunin_flexible",
  artist_open: "artist_mystery", artist_mystery: "artist_open"
};

const TYPE_DESC = {
  yanki_aniki: "現場での停滞や迷いに対して、決断と推進で状況を動かすタイプです。未整理な状態でも「まず進める」判断ができ、チームのエンジンとして機能します。一方で立ち止まって振り返る時間を取りにくく、自己省察や合意形成が弱いと、勢い先行で手戻りや疲弊を招くことがあります。推進力に内省や調整が伴うと、非常に安定したリーダータイプになります。",
  yanki_ubu: "責任感が強く、期待に応えようと前に出るものの、内面では評価や失敗を強く意識しているタイプです。断る判断が遅れやすく、負荷を抱え込みがちな傾向があります。周囲からのフォローや役割の整理があることで力を発揮しやすく、逆に放置されると消耗しやすい特徴があります。推進力はあるため、支え方次第で大きく伸びます。",
  otaku_you: "複雑な状況をロジックで整理し、論点や判断材料を共通言語として提示できるタイプです。感情論に流されず、前提や構造を明確にすることで、チーム全体の判断精度を高めます。ただし自ら強く決断するよりは判断を支える役割になりやすく、推進役と組むことで真価を発揮します。設計や企画の軸として信頼されやすい存在です。",
  otaku_in: "筋が通らない状態に強い違和感を持ち、品質や整合性を守る批評的なタイプです。問題点やリスクを見抜く力は高いものの、納得できないまま進むことを嫌うため、合意形成が弱いとブレーキ役に見られやすくなります。課題定義やレビュー局面では非常に有効で、意見が活きる設計が重要です。",
  shokunin_flexible: "制約や指摘を前向きに取り込みながら、完成度を高めていく実装志向のタイプです。個人の完成度だけでなく、チーム全体の品質を引き上げる動きができ、再現性のあるアウトプットを生み出します。主張が控えめな場合は便利な人に留まりやすいため、判断軸や意見を明確にすると、より中核的な役割を担えます。",
  shokunin_stubborn: "自分なりの美意識や基準を強く持ち、妥協せずに品質を追求するタイプです。深く刺さるアウトプットを出すことがあり、表現品質や実装力が高い場合はプロジェクトの要石になります。一方で共有や説明を省きがちで、自己省察が弱いと属人化や摩擦が生じやすくなります。視座更新がされにくいという課題もあります。扱うテーマと裁量の設計が重要です。",
  artist_open: "言語化しきれていない段階でも感覚や違和感を外に出し、場に刺激を与えるタイプです。停滞した議論に新しい視点を持ち込み、空気を変える触媒として機能します。視座更新力が高く、発想面で価値を発揮しますが、実装や着地を担う相棒がいない場合は、アイデアが広がるだけで終わることがあります。",
  artist_mystery: "独自の世界観や関心に深く没入し、他者に迎合せず探究を続けるタイプです。尖った視点や表現を生み出す力があり、視座更新や表現品質が突出することもあります。一方で説明や共有を後回しにしやすく、合意形成が弱いと周囲から理解されにくくなります。翻訳役や調整役がいる環境で真価を発揮します。"
};

// Grouping definitions
const SKILL_GROUPS = [
  { name: "① 定義・設計フェーズ", axes: ["skill_1", "skill_2"] },
  { name: "② 表現・実装フェーズ", axes: ["skill_3", "skill_4"] },
  { name: "③ チーム・行動", axes: ["skill_5", "skill_6", "skill_7"] }
];

const AXES = [
  { id:"skill_1", name:"課題定義力", category:"Skill",
    desc:"与えられた要望を鵜呑みにせず、「何を解くべきか」を見立て直し、論点と目的を明確にする力。",
    items:{
      self: [
        "与えられた課題の背景や目的を確認して着手している",
        "要件の抜けや誤解に気づき、整理し直している",
        "表面的な要望だけで判断しないようにしている",
        "ユーザー・事業・技術で課題を切り分けて考えている",
        "【Key2】課題の捉え方を見直し、設計方針を更新している",
        "【Key1】課題に対する「問い」を自ら設定できている"
      ],
      other: [
        "与えられた課題の背景や目的を確認している",
        "要望の前提や条件を整理し直して説明している",
        "表層の要望と本質的な課題のズレを指摘している",
        "ユーザー・事業・技術の視点を分けて課題を整理している",
        "【Key2】課題設定を見直すことで方針に影響を与えている",
        "【Key1】課題に対する「問い」を自ら設定できている"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_2", name:"コンセプト統合力", category:"Skill",
    desc:"複数の要件・制約・意見を一本の軸にまとめ、判断基準として機能するコンセプトに落とす力。",
    items:{
      self:[
        "複数の要件を整理し、方向性を言葉にしている",
        "判断に迷った時、立ち戻る軸を設定している",
        "認識のズレを、考え方や方向性で整えようとしている",
        "成果物全体で、同じ意図が伝わるよう設計している",
        "【Key2】コンセプトを基に、取捨選択や説明を行っている",
        "【Key1】実現性が未確定でも、方向性や構想をデザインで可視化し示している"
      ],
      other:[
        "複数の要件を整理し、方向性として説明している",
        "迷った際、コンセプトを判断基準として使っている",
        "メンバー間の認識のズレを、コンセプトで整えている",
        "資料や成果物に、コンセプトが一貫して表れている",
        "【Key2】関係者がコンセプトを前提に判断・議論している",
        "【Key1】実現性が未確定でも、方向性や構想をデザインで可視化し示している"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_3", name:"表現品質力", category:"Skill",
    desc:"情報設計と見た目の完成度で、少ない説明でも意図が伝わるアウトプットを安定して出す力。",
    items:{
      self:[
        "意図が誤解されないよう、形や情報をデザインしている",
        "CMF・形・構成・体験を通して内容を表現している",
        "何を伝えるかに応じて、表現の方法を選んでいる",
        "表現に関する知識やルールを体系的に理解し、活用している",
        "【Key2】説明に頼らず、体験や構成で意図が伝わるよう設計している",
        "【Key1】表現する対象や媒体が変わっても、品質を保てている"
      ],
      other:[
        "見た目や情報が整理され、意図が伝わりやすい",
        "CMF・形・構成・体験の工夫が表現に活かされている",
        "目的や伝えたい内容に応じて、表現方法を選んでいる",
        "表現の原則や型を体系的に理解し、意図的に使っている",
        "【Key2】説明がなくても内容が理解されている",
        "【Key1】対象や媒体が変わっても、表現品質が安定している"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_4", name:"実装・成立力", category:"Skill",
    desc:"技術・コスト・量産などの制約を踏まえ、成立する設計に落とし込み、手戻りを減らす力。",
    items:{
      self:[
        "技術・コストなどの前提条件を理解してデザイン・設計している",
        "成立しない案を早い段階で見極めている",
        "制約条件を踏まえ、現実的な代替案を考えている",
        "実装段階で手戻りが起きにくいデザイン・設計をしている",
        "【Key2】制約条件の中でも体験の質を保つよう工夫している",
        "【Key1】デザインの意図を基準に、前提や制約を見直して設計に反映している"
      ],
      other:[
        "技術・コストなどの前提を理解した提案をしている",
        "成立しない案を早期に見極め、修正している",
        "制約を踏まえた現実的な代替案を提示している",
        "実装段階で大きな手戻りを出していない",
        "【Key2】制約条件下でも体験の質が保たれている",
        "【Key1】デザインの意図を基準に、前提や制約の捉え方を更新している"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_5", name:"自己省察力", category:"Behavior",
    desc:"判断や行動を振り返って学びに変え、指摘や失敗を次のプロジェクトで具体的に更新する力。",
    items:{
      self:[
        "自身の強みや苦手な点を把握している",
        "指摘や意見を、素直に受け止めようとしている",
        "結果の良し悪しを分けた要因を捉えようとしている",
        "経験や指摘を、次の判断に反映している",
        "【Key2】気づきをもとに行動を変え、成果が改善した経験がある",
        "【Key1】指摘や失敗を受け、判断や行動を継続的に更新している"
      ],
      other:[
        "自身の強みや苦手な点を理解しているように見える",
        "指摘や意見に対し、防御的にならず受け止めている",
        "結果の良し悪しを分けた要因を整理して捉えている",
        "経験や指摘が、次の判断に反映されている",
        "【Key2】振る舞いや判断が変わり、成果の改善が見られる",
        "【Key1】指摘や失敗を踏まえ、判断や行動を継続的に更新している"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_6", name:"合意形成力", category:"Behavior",
    desc:"関係者の立場と論点を整理し、必要情報を揃えて意思決定を前に進める力。",
    items:{
      self:[
        "関係者ごとに立場や関心が異なることを意識している",
        "意見が割れた際、論点を整理して話そうとしている",
        "会議やレビューで、結論に向けた進行を意識している",
        "合意に必要な情報や判断材料を事前に揃えている",
        "【Key2】意思決定に必要な会議体やレビュー体制を設計している",
        "【Key1】デザインの意図や理想を理由とともに説明し、合意を得ている"
      ],
      other:[
        "関係者ごとの立場や関心を踏まえた発言や整理が見られる",
        "意見が割れた場面で、論点を整理して対話を促している",
        "会議やレビューが結論に向かうよう進行している",
        "合意に必要な情報や判断材料が事前に整理・共有されている",
        "【Key2】意思決定に必要な会議体やレビューの進め方を設計している",
        "【Key1】デザインの意図や理想を理由とともに説明し、合意を得ている"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },

  { id:"skill_7", name:"視座更新力", category:"Behavior",
    desc:"トレンド・先行事例・新技術を継続的に取り込み、プロジェクトに新しい視点や仮説を持ち込む力。",
    items:{
      self:[
        "自分が関わるデザイン分野の動向を継続的に把握している",
        "自分が直接関わらないデザイン分野や、デザイン以外の分野の動向・事例にも目を向けている",
        "先行事例や過去の取り組みを踏まえ、中長期の変化も意識して考えている",
        "新しいツールや手法を試し、実務に取り入れている",
        "【Key2】得た知見やノウハウを、周囲に共有するよう意識している",
        "【Key1】得た視点や知見をもとに、アウトプットや提案を更新している"
      ],
      other:[
        "担当分野のデザイン動向を把握している様子が見られる",
        "担当領域外のデザイン分野や、デザイン以外の分野の動向・事例も取り入れている",
        "先行事例や過去の事例を踏まえ、中長期視点での発言や検討がある",
        "新しいツールや手法を試し、実務で活用している",
        "【Key2】得ている知見やノウハウを共有したり、相談を受けている",
        "【Key1】得た知見をアウトプットや提案に反映し、内容を更新している"
      ]
    },
    gateRules:{ minCountLv2:2, minCountLv3:3, key1:[5], key2:[4] }
  },
];

const TYPE_TEMPLATES = {
  yanki_aniki:      [3,3,3,4,2,4,3],
  yanki_ubu:        [3,3,3,3,2,3,3],
  otaku_you:        [4,4,3,3,3,3,3],
  otaku_in:         [4,3,3,3,2,2,3],
  shokunin_flexible:[3,3,3,4,3,3,3],
  shokunin_stubborn:[3,2,3,4,2,2,2],
  artist_open:      [4,3,4,2,3,3,4],
  artist_mystery:   [4,3,4,2,2,2,4]
};

const SELF_Q = [
  {id:"S01", t:"状況が未整理でも、「まずはここまで」と区切って前に進める判断ができる", type:"yanki_aniki", w:2},
  {id:"S02", t:"議論が停滞した際は、自分が叩き台や仮の結論を出して空気を動かす", type:"yanki_aniki", w:1},
  {id:"S03", t:"机上で考え込むより、動きながら修正していくスタイルが合っている", type:"yanki_aniki", w:1},
  {id:"S04", t:"期待されると、少し背伸びをしてでも応えようと頑張ってしまう", type:"yanki_ubu", w:2},
  {id:"S05", t:"不安なことがあっても、表向きは気丈に振る舞うことが多い", type:"yanki_ubu", w:1},
  {id:"S06", t:"頼られると断るのが難しく、自分のキャパシティを超えてしまいがちだ", type:"yanki_ubu", w:1},
  {id:"S07", t:"感情や勢いだけでなく、事実やロジックで整理した方が納得感がある", type:"otaku_you", w:2},
  {id:"S08", t:"複雑な要件を整理し、関係者が理解しやすい言葉に直すのが得意だ", type:"otaku_you", w:1},
  {id:"S09", t:"判断に迷った時は、まず「何を基準に決めるか」という物差しを作る", type:"otaku_you", w:1},
  {id:"S10", t:"自分の中で筋が通っていない方針には、違和感を持ちやすい", type:"otaku_in", w:2},
  {id:"S11", t:"「とりあえず進めよう」と言われると、潜在的なリスクや矛盾が気になる", type:"otaku_in", w:1},
  {id:"S12", t:"議論が散らかった時は、一度持ち帰って静かに思考を整理したい", type:"otaku_in", w:1},
  {id:"S13", t:"自分のこだわりよりも、チームの合意やユーザーの要望を形にしたい", type:"shokunin_flexible", w:2},
  {id:"S14", t:"完成手前のラフな状態でも、こまめに共有してフィードバックをもらう", type:"shokunin_flexible", w:1},
  {id:"S15", t:"制約条件がある方が、工夫のしがいがあって燃えるタイプだ", type:"shokunin_flexible", w:1},
  {id:"S16", t:"ある程度納得できる品質になるまでは、自分の中で温めておきたい", type:"shokunin_stubborn", w:2},
  {id:"S17", t:"周囲の評価も大事だが、自分の美意識や品質基準をより大切にしたい", type:"shokunin_stubborn", w:1},
  {id:"S18", t:"説明資料を作る時間があったら、アウトプット自体の精度を上げたい", type:"shokunin_stubborn", w:1},
  {id:"S19", t:"言葉にならない違和感やアイデアでも、とりあえず場に出してみる", type:"artist_open", w:2},
  {id:"S20", t:"停滞した空気を、新しい視点や発想で切り替えることができる", type:"artist_open", w:1},
  {id:"S21", t:"一人で黙々と考えるより、他人と会話しながら発想を広げたい", type:"artist_open", w:1},
  {id:"S22", t:"独自の関心領域があり、周囲の理解が得にくくても深掘りしたい", type:"artist_mystery", w:2},
  {id:"S23", t:"常識や前例にとらわれず、独自の角度から物事を見ていることが多い", type:"artist_mystery", w:1},
  {id:"S24", t:"頭の中にあるイメージを、言葉で説明することに難しさを感じる", type:"artist_mystery", w:1}
];

const OTHER_Q = [
  {id:"O01", p:"仕様が未定で進まない時の反応は？",
    A:{t:"仮決定をして、まず前に進める", type:"yanki_aniki"},
    B:{t:"前提条件を整理し直す", type:"otaku_you"}},
  {id:"O02", p:"スケジュールが厳しい局面での動きは？",
    A:{t:"期限を守ることを最優先にする", type:"yanki_aniki"},
    B:{t:"関係者と調整して着地点を探る", type:"shokunin_flexible"}},
  {id:"O03", p:"アイデア出しの場での振る舞いは？",
    A:{t:"現実的な実現案を素早く探る", type:"yanki_aniki"},
    B:{t:"意外性のあるアイデアで場を刺激する", type:"artist_open"}},
  {id:"O04", p:"トラブル発生時の初動は？",
    A:{t:"自ら率先して動き、指示を出す", type:"yanki_aniki"},
    B:{t:"不安だが「大丈夫」と引き受ける", type:"yanki_ubu"}}, 
  {id:"O05", p:"曖昧な指示が来た時の対応は？",
    A:{t:"「まずは形にしてみます」と動く", type:"yanki_aniki"},
    B:{t:"目的や背景を丁寧に確認する", type:"otaku_in"}},
  {id:"O06", p:"品質基準で意見が割れたときは？",
    A:{t:"スピードや効率を優先する", type:"yanki_aniki"},
    B:{t:"自身の品質基準を優先する", type:"shokunin_stubborn"}},
  {id:"O07", p:"全く新しい技術へのスタンスは？",
    A:{t:"使えるならすぐに試してみる", type:"yanki_aniki"},
    B:{t:"独自の世界観に取り込めそうか考える", type:"artist_mystery"}},
  {id:"O08", p:"難しい修正依頼が来たときは？",
    A:{t:"期待に応えようと引き受ける", type:"yanki_ubu"},
    B:{t:"矛盾点を指摘して調整する", type:"otaku_in"}},
  {id:"O09", p:"タスク過多になった時の様子は？",
    A:{t:"責任感から一人で頑張ろうとする", type:"yanki_ubu"},
    B:{t:"周囲と連携しながらこなす", type:"shokunin_flexible"}},
  {id:"O10", p:"大きなチャンスが来た時の反応は？",
    A:{t:"失敗しないよう入念に準備する", type:"yanki_ubu"},
    B:{t:"面白そうなら直感で飛びつく", type:"artist_open"}},
  {id:"O11", p:"意思決定を迫られたときは？",
    A:{t:"正解かどうか慎重になる", type:"yanki_ubu"},
    B:{t:"判断基準を作って決める", type:"otaku_you"}},
  {id:"O12", p:"周囲からの評価については？",
    A:{t:"期待されているか気にする方だ", type:"yanki_ubu"},
    B:{t:"あまり気にしていないようだ", type:"artist_mystery"}},
  {id:"O13", p:"フィードバックを受けた時の反応は？",
    A:{t:"構造的に整理して理解する", type:"otaku_you"},
    B:{t:"柔軟に取り入れて改善する", type:"shokunin_flexible"}},
  {id:"O14", p:"新しい企画を提案するときは？",
    A:{t:"ロジックと根拠を固めて出す", type:"otaku_you"},
    B:{t:"未完成でも感覚や兆しを共有する", type:"artist_open"}},
  {id:"O15", p:"議論が紛糾したときは？",
    A:{t:"論点を整理して交通整理する", type:"otaku_you"},
    B:{t:"納得いくまで立ち止まって考える", type:"otaku_in"}}, 
  {id:"O16", p:"アウトプットのこだわり方は？",
    A:{t:"説明可能性や整合性を重視", type:"otaku_you"},
    B:{t:"細部の美しさや完成度を重視", type:"shokunin_stubborn"}},
  {id:"O17", p:"興味の対象は？",
    A:{t:"仕組みや構造の解明", type:"otaku_you"},
    B:{t:"独自の深淵な世界観", type:"artist_mystery"}},
  {id:"O18", p:"納得できない仕様に対する態度は？",
    A:{t:"懸念点を伝えて慎重になる", type:"otaku_in"},
    B:{t:"自分の美学でより良く上書きする", type:"shokunin_stubborn"}},
  {id:"O19", p:"他者とのコミュニケーションは？",
    A:{t:"内省や思考の時間を大切にする", type:"otaku_in"},
    B:{t:"理解されなくても気にしない", type:"artist_mystery"}},
  {id:"O20", p:"チームでの立ち位置は？",
    A:{t:"リスクや課題を見つける役", type:"otaku_in"},
    B:{t:"空気を変える発想役", type:"artist_open"}},
  {id:"O21", p:"作業の進め方で近いのは？",
    A:{t:"対話しながら形を作る", type:"shokunin_flexible"},
    B:{t:"一人で没頭して作り込む", type:"shokunin_stubborn"}}, 
  {id:"O22", p:"アイデアの広げ方は？",
    A:{t:"実現可能な範囲で着実に広げる", type:"shokunin_flexible"},
    B:{t:"制限なく自由に広げる", type:"artist_open"}},
  {id:"O23", p:"未知の領域に取り組むときは？",
    A:{t:"既存の手法を応用して挑む", type:"shokunin_flexible"},
    B:{t:"独自のやり方を探究する", type:"artist_mystery"}},
  {id:"O24", p:"完成したものに対する態度は？",
    A:{t:"細部まで完璧に仕上げたい", type:"shokunin_stubborn"},
    B:{t:"他人の反応を見て変化させたい", type:"artist_open"}}
];

const TYPE_MAP = {
  yanki_aniki:        { x:-0.9, y: 0.4, group:'open' },
  yanki_ubu:          { x:-0.7, y:-0.2, group:'close' },
  otaku_you:          { x: 0.8, y: 0.4, group:'open' },
  otaku_in:           { x: 0.8, y:-0.4, group:'close' },
  shokunin_flexible:  { x:-0.4, y:-0.7, group:'open' },
  shokunin_stubborn:  { x: 0.3, y:-0.8, group:'close' },
  artist_open:        { x:-0.5, y: 0.7, group:'open' },
  artist_mystery:     { x: 0.5, y: 0.8, group:'close' }
};

/* =========================
   APP STATE
========================= */
const app = {
  mode: null,
  scopeText: "",
  typeSkipped: false,
  typeQ: [],
  typeIdx: 0,
  typeAnswers: [],
  typeScores: {},
  skillChecks: {},
  skillLevels: {},
  mainType: null,
  subType: null,
  radarChart: null
};
const $ = (id)=>document.getElementById(id);

function initScores(){
  app.typeScores = {};
  TYPES.forEach(t => app.typeScores[t.id] = 0);
}
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function typeLabel(id){ return TYPES.find(t=>t.id===id)?.label ?? id; }
function typeDesignerLabel(id){ return `${typeLabel(id)}系デザイナー`; }

function show(viewId){
  ["view-home","view-type","view-skill","view-result"].forEach(v=>$(v).classList.add("hidden"));
  $(viewId).classList.remove("hidden");
  window.scrollTo({top:0, behavior:"smooth"});
}

function resetAll(){
  app.mode = null;
  app.typeSkipped = false;
  app.scopeText = "";
  app.typeQ = [];
  app.typeIdx = 0;
  app.typeAnswers = [];
  initScores();
  AXES.forEach(ax => app.skillChecks[ax.id] = Array(ax.items.other.length).fill(false));
  app.skillLevels = {};
  app.mainType = null;
  app.subType = null;

  document.querySelectorAll('[data-mode]').forEach(el=>el.classList.remove("selected"));
  $("btnStart").disabled = true;
  $("btnSkip").disabled = true;
  $("scopeText").value = "";
}

function setMode(mode){
  app.mode = mode;
  document.querySelectorAll('[data-mode]').forEach(el=>{
    el.classList.toggle("selected", el.dataset.mode===mode);
  });
  $("btnStart").disabled = !app.mode;
  $("btnSkip").disabled = !app.mode;
}

function startTypeTest(){
  app.scopeText = $("scopeText").value.trim();
  initScores();
  app.typeAnswers = [];
  app.typeIdx = 0;
  app.typeSkipped = false;
  app.typeQ = (app.mode==="self") ? shuffle(SELF_Q) : shuffle(OTHER_Q);

  $("modeBadge").textContent = (app.mode==="self") ? "自己評価" : "客観評価";
  // 修正: タイプ判定画面にもモードを表示
  const modeText = (app.mode === 'self') ? "【自己評価】" : "【客観評価】";
  $("typeModeDisplay").textContent = `現在は${modeText}モードです`;

  renderTypeQuestion();
  show("view-type");
}

function skipTypeTest(){
  app.scopeText = $("scopeText").value.trim();
  app.typeSkipped = true;
  app.mainType = null;
  app.subType = null;
  buildSkillUI();
  show("view-skill");
}

/* ===== Type Diagnosis ===== */
function renderTypeQuestion(){
  const total = app.typeQ.length;
  const idx = app.typeIdx;
  $("qCounter").textContent = `${idx+1}/${total}`;
  $("qBar").style.width = `${Math.round((idx)/total*100)}%`;
  const q = app.typeQ[idx];
  $("qIdText").textContent = q.id;

  $("selfChoices").classList.add("hidden");
  $("otherChoices").classList.add("hidden");
  $("selfChoices").innerHTML = "";
  $("otherChoices").innerHTML = "";

  if(app.mode==="self"){
    $("qText").textContent = q.t;
    const options = [
      {label:"とてもそう思う", val: 2}, {label:"ややそう思う", val: 1},
      {label:"あまりそう思わない", val:-1}, {label:"そう思わない", val:-2}
    ];
    options.forEach((op, i)=>{
      const div = document.createElement("div");
      div.className = "tap";
      div.innerHTML = `
        <div class="left"><div class="title"><span style="margin-right:8px; font-weight:900;">${i+1}</span>${op.label}</div></div>
        <div class="chev">›</div>`;
      div.onclick = ()=>answerSelf(q, op.val);
      $("selfChoices").appendChild(div);
    });
    $("selfChoices").classList.remove("hidden");
  }else{
    $("qText").textContent = q.p;
    
    ["A","B"].forEach(key=>{
      const div = document.createElement("div");
      div.className = "tap";
      div.innerHTML = `
        <div class="left"><div class="title"><span style="margin-right:8px; font-weight:900;">${key}</span>${q[key].t}</div></div>
        <div class="chev">›</div>`;
      div.onclick = ()=>answerOther(q, key);
      $("otherChoices").appendChild(div);
    });

    const divC = document.createElement("div");
    divC.className = "tap neutral";
    divC.innerHTML = `
      <div class="left">
        <div class="title"><span style="margin-right:8px; font-weight:900;">C</span>どちらともいえない（判断材料が不足 / 場面による）</div>
      </div>
      <div class="chev">›</div>`;
    divC.onclick = ()=>answerOther(q, "C");
    $("otherChoices").appendChild(divC);

    $("otherChoices").classList.remove("hidden");
  }
  $("btnTypeBack").disabled = false;
}

function answerSelf(q, val){
  const v = (val < 0) ? val * 0.5 : val; 
  app.typeScores[q.type] += v * q.w;
  app.typeAnswers.push({qid:q.id, val, v, type:q.type, w:q.w});
  advanceType();
}

function answerOther(q, pick){
  if(pick === "C"){
    app.typeAnswers.push({qid:q.id, pick, scoreDetails: null});
    advanceType();
    return;
  }

  const selectedType = (pick === "A") ? q.A.type : q.B.type;
  const opposingType = (pick === "A") ? q.B.type : q.A.type;
  const relatedType  = RELATED_TYPES[selectedType];

  app.typeScores[selectedType] += 1.0;

  let addedRelated = false;
  if(opposingType !== relatedType){
    app.typeScores[relatedType] += 0.5;
    addedRelated = true;
  }

  app.typeAnswers.push({ qid: q.id, pick, selectedType, relatedType, addedRelated });
  advanceType();
}

function advanceType(){
  app.typeIdx++;
  if(app.typeIdx >= app.typeQ.length){
    finalizeTypes();
    buildSkillUI();
    show("view-skill");
    return;
  }
  renderTypeQuestion();
}

function backType(){
  if(app.typeIdx<=0) return;
  app.typeIdx--;
  
  const lastAns = app.typeAnswers.pop();
  const q = app.typeQ.find(x=>x.id===lastAns.qid);

  if(app.mode==="self"){
    const v = (lastAns.v !== undefined) ? lastAns.v : lastAns.val;
    app.typeScores[q.type] -= v * q.w;
  }else{
    if(lastAns.pick !== "C"){
      app.typeScores[lastAns.selectedType] -= 1.0;
      if(lastAns.addedRelated){
        app.typeScores[lastAns.relatedType] -= 0.5;
      }
    }
  }
  renderTypeQuestion();
}

function finalizeTypes(){
  const order = TYPES.map(t=>t.id);
  const sorted = TYPES
    .map(t=>({id:t.id, score:app.typeScores[t.id], idx:order.indexOf(t.id)}))
    .sort((x,y)=> (y.score - x.score) || (x.idx - y.idx));
  
  app.mainType = sorted[0].id;
  
  const scoreDiff = sorted[0].score - sorted[1].score;
  const GAP_THRESHOLD = 4; 

  if(scoreDiff >= GAP_THRESHOLD){
    app.subType = null;
  } else {
    app.subType = sorted[1].id;
  }
}

/* ===== Skill Diagnosis ===== */
function anyChecked(arr, idxs){ return idxs.some(i => !!arr[i]); }
function calcAxisLevel(axisId){
  const ax = AXES.find(a=>a.id===axisId);
  const checks = app.skillChecks[axisId] || [];
  const count = checks.filter(Boolean).length;
  const g = ax.gateRules;

  // Key判定（index指定）
  const hasKey1 = (g.key1 || []).some(i => !!checks[i]);
  const hasKey2 = (g.key2 || []).some(i => !!checks[i]);

  // Lv2 / Lv3（Key不要）
  const pass2 = (count >= g.minCountLv2);
  const pass3 = pass2 && (count >= g.minCountLv3);

  // Lv4：Lv3を満たしつつ
  // (A) チェック 5個以上 OR
  // (B) チェック 4個 かつ Key1
  const pass4 = pass3 && ( (count >= 5) || (count === 4 && hasKey1) );

  // Lv5：Lv4を満たしつつ
  // (A) チェック 6個（すべてにチェック） OR
  // (B) チェック 5個以上 かつ Key1とKey2
  const pass5 = pass4 && ( (count === 6) || (count >= 5 && hasKey1 && hasKey2) );

  if(pass5) return 5;
  if(pass4) return 4;
  if(pass3) return 3;
  if(pass2) return 2;
  return 1;
}

// 修正: buildSkillUI でグループ化とランダム配置
function buildSkillUI(){
  const root = $("skillAccordions");
  root.innerHTML = "";
  
  const modeText = (app.mode === 'self') ? "【自己評価】" : "【客観評価】";
  $("skillModeDisplay").textContent = `現在は${modeText}モードです`;

  const modeKey = (app.mode === 'self') ? 'self' : 'other';

  // 修正: 影なし、線ありのデザインに変更
  SKILL_GROUPS.forEach(grp => {
    const card = document.createElement("div");
    // surfaceクラスの影を無効化し、ボーダーを追加
    card.style.background = "var(--surface)";
    card.style.borderRadius = "var(--radius)";
    card.style.padding = "20px";
    card.style.marginBottom = "0";
    card.style.boxShadow = "none"; // 影なし
    card.style.border = "1px solid var(--line)"; // 線あり

    const title = document.createElement("div");
    title.style.fontWeight = "900";
    title.style.fontSize = "16px";
    title.style.color = "var(--text)";
    title.style.marginBottom = "12px";
    title.style.borderBottom = "2px solid var(--line)";
    title.style.paddingBottom = "8px";
    title.textContent = grp.name;
    card.appendChild(title);

    let groupItems = [];
    grp.axes.forEach(axId => {
       const ax = AXES.find(a=>a.id===axId);
       const items = ax.items[modeKey];
       items.forEach((txtRaw, i) => {
         const displayTxt = txtRaw.replace("【Key】", "").replace("【Key1】", "").replace("【Key2】", "");
         groupItems.push({ txt: displayTxt, axisId: axId, idx: i });
       });
    });
    
    const shuffled = shuffle(groupItems);

    const listDiv = document.createElement("div");
    listDiv.style.display = "flex";
    listDiv.style.flexDirection = "column";
    listDiv.style.gap = "8px";

    shuffled.forEach((item) => {
      const row = document.createElement("label");
      row.className = "chk";
      row.style.borderTop = "none";
      row.style.borderBottom = "1px solid var(--line2)";
      
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = !!app.skillChecks[item.axisId][item.idx];
      cb.onchange = ()=>{ app.skillChecks[item.axisId][item.idx] = cb.checked; };

      const span = document.createElement("span");
      span.style.fontSize = "13px";
      span.style.lineHeight = "1.5";
      span.textContent = item.txt;
      
      row.appendChild(cb);
      row.appendChild(span);
      listDiv.appendChild(row);
    });

    card.appendChild(listDiv);
    root.appendChild(card);
  });
}

function finalizeSkills(){
  app.skillLevels = {};
  AXES.forEach(ax=>{ app.skillLevels[ax.id] = calcAxisLevel(ax.id); });
}

function toResult(){
  finalizeSkills();
  renderResult();
  show("view-result");
}

/* ===== Visualization ===== */
function renderTypeMapSVG(mainId, subId){
  if(!mainId) return "";
  
  const W=560, H=360, pad=40, cx=W/2, cy=H/2, s=140;

  const axisLabelColor = "#9ca3af"; 
  const axisLabelSize  = "12";      
  const typeLabelSize  = "11";      
  const colorOpen      = "#c2410c"; 
  const colorClose     = "#1e3a8a"; 
  const dotR_Base = 6;  
  const dotR_Main = 9;  
  const dotR_Sub  = 11; 

  const axisColor="#e5e7eb";
  const mainColor="#f97316"; 

  let svg = `<svg viewBox="0 0 ${W} ${H}" width="100%" style="font-family:'Jost', 'Noto Sans JP', sans-serif;">`;
  
  svg += `<line x1="${cx}" y1="${pad}" x2="${cx}" y2="${H-pad}" stroke="${axisColor}"/>`;
  svg += `<line x1="${pad}" y1="${cy}" x2="${W-pad}" y2="${cy}" stroke="${axisColor}"/>`;
  
  svg += `<text x="${pad}" y="${cy-10}" fill="${axisLabelColor}" font-size="${axisLabelSize}" font-weight="700">推進</text>`;
  svg += `<text x="${W-pad}" y="${cy-10}" fill="${axisLabelColor}" font-size="${axisLabelSize}" text-anchor="end" font-weight="700">分析</text>`;
  svg += `<text x="${cx}" y="${pad-10}" fill="${axisLabelColor}" font-size="${axisLabelSize}" text-anchor="middle" font-weight="700">発想</text>`;
  svg += `<text x="${cx}" y="${H-pad+22}" fill="${axisLabelColor}" font-size="${axisLabelSize}" text-anchor="middle" font-weight="700">実装</text>`;

  TYPES.forEach(t=>{
    const m = TYPE_MAP[t.id];
    if(!m) return;
    const x = cx + m.x*s, y = cy - m.y*s;
    const right = x >= cx;
    const top = y <= cy;
    const lx = x + (right ? 12 : -12); 
    const ly = y + (top ? -10 : 16);
    const anc = right ? "start" : "end";

    const txtColor = (m.group === 'open') ? colorOpen : colorClose;
    const dotColor = "#d1d5db";

    svg += `<circle cx="${x}" cy="${y}" r="${dotR_Base}" fill="${dotColor}"/>`;
    svg += `<text x="${lx}" y="${ly}" font-size="${typeLabelSize}" fill="${txtColor}" font-weight="700" text-anchor="${anc}">${t.label}</text>`;
  });

  const pm = TYPE_MAP[mainId];
  if(pm){
    svg += `<circle cx="${cx+pm.x*s}" cy="${cy-pm.y*s}" r="${dotR_Main * 3}" fill="${mainColor}" opacity="0.15"/>`; 
    svg += `<circle cx="${cx+pm.x*s}" cy="${cy-pm.y*s}" r="${dotR_Main}" fill="${mainColor}"/>`;
  }

  if(subId && TYPE_MAP[subId]){
    const ps = TYPE_MAP[subId];
    svg += `<circle cx="${cx+ps.x*s}" cy="${cy-ps.y*s}" r="${dotR_Sub}" fill="none" stroke="${mainColor}" stroke-width="2"/>`;
  }
  
  svg += `</svg>`;
  return svg;
}

function renderResult(){
  $("resultMode").textContent = app.mode ? (app.mode==="self"?"自己評価":"客観評価") : "評価モードなし";
  
  const sText = app.scopeText || $("scopeText").value || "—";
  $("resultScope").textContent = `スコープ：${sText}`;

  if(app.typeSkipped){
    $("typeResultContent").classList.add("hidden");
    $("typeResultSkipped").classList.remove("hidden");
    $("radarTypicalLabel").classList.add("hidden");
  } else {
    $("typeResultContent").classList.remove("hidden");
    $("typeResultSkipped").classList.add("hidden");
    $("radarTypicalLabel").classList.remove("hidden");

    $("mainTypeText").textContent = typeDesignerLabel(app.mainType);
    if(app.subType){
      $("subTypeText").textContent = typeDesignerLabel(app.subType);
      $("subTypeText").style.color = "var(--text)";
      $("typeDesc").textContent = 
        `【メイン】${typeLabel(app.mainType)}：${TYPE_DESC[app.mainType]}\n\n` +
        `【サブ】${typeLabel(app.subType)}：${TYPE_DESC[app.subType]}`;
    } else {
      $("subTypeText").textContent = "なし（メイン特化）";
      $("subTypeText").style.color = "var(--muted)";
      $("typeDesc").textContent = 
        `【メイン】${typeLabel(app.mainType)}：${TYPE_DESC[app.mainType]}\n\n` +
        `（スコア差が大きいため、このタイプの特性が特に強く出ています）`;
    }

    $("typeMapWrap").innerHTML = renderTypeMapSVG(app.mainType, app.subType);

    const pm = TYPE_MAP[app.mainType];
    const isOpen = (pm.group === 'open');

    const styleBase = "font-size:11px; font-weight:700; padding:6px 14px; border-radius:99px; transition:all 0.3s; display:flex; align-items:center; gap:6px;";
    const styleOpenOn  = "background:#fff7ed; color:#c2410c; border:1px solid #c2410c; opacity:1;";
    const styleCloseOn = "background:#f0f9ff; color:#1e3a8a; border:1px solid #1e3a8a; opacity:1;";
    const styleOff     = "background:transparent; color:#d1d5db; border:1px solid #e5e7eb; opacity:0.5;";

    const htmlAttr = `
      <div style="margin-top:16px; padding-top:12px; border-top:1px dashed var(--line); display:flex; flex-direction:column; align-items:center;">
        <div class="type-label-tag" style="margin-bottom:8px;">メイン属性</div>
        <div style="display:flex; gap:12px;">
          <div style="${styleBase} ${isOpen ? styleOpenOn : styleOff}">
            <span>OPEN 属性</span>
          </div>
          <div style="${styleBase} ${!isOpen ? styleCloseOn : styleOff}">
            <span>CLOSE 属性</span>
          </div>
        </div>
      </div>
    `;
    $("typeMapWrap").insertAdjacentHTML('beforeend', htmlAttr);
  }

  const listContainer = $("skillList");
  listContainer.innerHTML = "";
  const renderGroup = (groupLabel, axes) => {
    if(axes.length === 0) return;
    const grpTitle = document.createElement("div");
    grpTitle.className = "skill-category-label";
    grpTitle.textContent = groupLabel;
    listContainer.appendChild(grpTitle);

    axes.forEach(ax=>{
      const lv = app.skillLevels[ax.id];
      const diff = lv - 3;
      const diffTxt = (diff===0) ? "±0" : (diff>0 ? `+${diff}` : `${diff}`);
      const barW = Math.max(5, (lv/5)*100);
      const line = document.createElement("div");
      line.style.padding="8px 0";
      line.style.fontSize="13px";
      line.innerHTML = `
        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:flex-end;">
          <b>${ax.name}</b>
          <span>Lv${lv} <span style="color:#9ca3af; font-size:11px">(${diffTxt})</span></span>
        </div>
        <div style="height:6px; width:100%; background:#f3f4f6; border-radius:99px; overflow:hidden; margin-bottom:4px;">
          <div style="height:100%; width:${barW}%; background:var(--acc);"></div>
        </div>
        <div class="skill-desc">${ax.desc}</div>
      `;
      listContainer.appendChild(line);
    });
  };

  const skills = AXES.filter(a => a.category === "Skill");
  const behaviors = AXES.filter(a => a.category === "Behavior");
  renderGroup("Skill (スキル)", skills);
  renderGroup("Behavior (行動・態度)", behaviors);

  const labels = AXES.map(a=>a.name);
  const actual = AXES.map(a=>app.skillLevels[a.id]);
  const avg = labels.map(_=>3);
  
  const datasets = [
    { label:"実測", data: actual, borderWidth: 3, borderColor:"#f97316", backgroundColor:"rgba(249, 115, 22, 0.1)", pointRadius: 3 },
    { label:"平均(Lv3)", data: avg, borderWidth: 1, borderDash: [5,5], borderColor:"#9ca3af", pointRadius: 0 }
  ];
  if(!app.typeSkipped && app.mainType && TYPE_TEMPLATES[app.mainType]){
    datasets.push({
      label:`メインタイプ典型`,
      data: TYPE_TEMPLATES[app.mainType],
      borderWidth: 2, borderDash: [5,5], borderColor:"#1e3a8a", pointRadius: 0
    });
  }

  const ctx = $("radar").getContext("2d");
  if(app.radarChart) app.radarChart.destroy();
  app.radarChart = new Chart(ctx, {
    type: "radar",
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: { r: { min:0, max:5, ticks:{ stepSize:1, showLabelBackdrop:false }, grid:{ circular:true } } },
      plugins: { legend: { position:'bottom', labels: { boxWidth:12, padding:10, font:{size:11} } } }
    }
  });
}

function downloadPNG(){
  const target = $("captureArea");
  
  // ★ 強制的に文字と色を指定して画像化する（空欄防止）
  const modeMap = { "self": "自己評価", "other": "客観評価" };
  const currentMode = modeMap[app.mode] || "-";
  const currentScope = $("scopeText").value || app.scopeText || "—";

  $("resultMode").textContent = currentMode;
  $("resultScope").textContent = `スコープ：${currentScope}`;

  html2canvas(target, { 
    scale: 2,
    scrollX: 0, 
    scrollY: -window.scrollY, 
    onclone: (clonedDoc) => {
      const clonedElement = clonedDoc.getElementById("captureArea");
      clonedElement.style.padding = "40px"; 
      clonedElement.style.boxSizing = "border-box";
      
      const cMode = clonedDoc.getElementById("resultMode");
      const cScope = clonedDoc.getElementById("resultScope");
      
      // クローン側にも強制適用 & 色指定（白飛び防止）
      if(cMode) {
        cMode.textContent = currentMode;
        cMode.style.color = "#374151"; 
        cMode.style.visibility = "visible";
      }
      if(cScope) {
        cScope.textContent = `スコープ：${currentScope}`;
        cScope.style.color = "#374151";
        cScope.style.visibility = "visible";
      }
    }
  }).then(canvas => {
    const link = document.createElement('a');
    link.download = `pd_diag_${new Date().getTime()}.png`;
    link.href = canvas.toDataURL();
    link.click();
  });
}

function downloadCSV(){
  const bom = "\uFEFF";
  let csv = "Category,Group,Key,Value\n";
  
  const modeMap = { "self": "自己評価", "other": "客観評価" };
  const modeStr = modeMap[app.mode] || "-";
  const scopeStr = app.scopeText || $("scopeText").value || "";

  csv += `Meta,-,Date,${new Date().toLocaleString()}\n`;
  csv += `Meta,-,Mode,${modeStr}\n`;
  csv += `Meta,-,Scope,"${scopeStr}"\n`;
  
  if(!app.typeSkipped){
    csv += `Type,-,Main,${typeDesignerLabel(app.mainType)}\n`;
    const subLabel = app.subType ? typeDesignerLabel(app.subType) : "なし（メイン特化）";
    csv += `Type,-,Sub,${subLabel}\n`;
  } else {
    csv += `Type,-,Main,Skipped\n`;
  }
  
  AXES.forEach(ax=>{ csv += `Skill,${ax.category},${ax.name},${app.skillLevels[ax.id]}\n`; });
  
  const blob = new Blob([bom + csv], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.download = `pd_diag_${new Date().getTime()}.csv`;
  a.href = url;
  a.click();
  URL.revokeObjectURL(url);
}

/* =========================
   EVENTS & INIT
========================= */
resetAll();

document.querySelectorAll('[data-mode]').forEach(el=>{
  const click = ()=>setMode(el.dataset.mode);
  el.addEventListener("click", click);
});

$("btnStart").addEventListener("click", startTypeTest);
$("btnSkip").addEventListener("click", skipTypeTest);

$("btnTypeBack").addEventListener("click", ()=>{
  if(app.typeIdx === 0){
    resetAll();
    show("view-home");
  } else {
    backType();
  }
});

$("btnTypeReset").addEventListener("click", ()=>{ resetAll(); show("view-home"); });

$("btnSkillBack").addEventListener("click", ()=>{ 
  if(app.typeSkipped){ resetAll(); show("view-home"); }
  else { show("view-type"); renderTypeQuestion(); }
});
$("btnToResult").addEventListener("click", toResult);

$("btnResultBack").addEventListener("click", ()=>{ show("view-skill"); });
$("btnRestart").addEventListener("click", ()=>{ resetAll(); show("view-home"); });
$("btnExportCSV").addEventListener("click", downloadCSV);
$("btnExportPNG").addEventListener("click", downloadPNG);

</script>
</body>
</html>
