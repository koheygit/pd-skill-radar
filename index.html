<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PD診断：8タイプ＋能力6軸（レーダー重ね表示）</title>
  <style>
    :root { --bg:#f6f6f6; --card:#fff; --bd:#e6e6e6; --txt:#111; --muted:#666; }
    body { margin:0; background:var(--bg); color:var(--txt);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif; }
    .wrap { max-width: 1180px; margin: 0 auto; padding: 16px; }
    .card { background:var(--card); border:1px solid var(--bd); border-radius:14px; padding:14px; margin-bottom:12px; }
    h1 { font-size:18px; margin:0 0 8px; }
    h2 { font-size:15px; margin:0 0 10px; }
    .muted { color:var(--muted); font-size:13px; line-height:1.55; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .tabBtn { border:1px solid var(--bd); background:#fff; padding:10px 12px; border-radius:12px; cursor:pointer; font-size:13px; }
    .tabBtn.active { background:#f0f0f0; font-weight:700; }
    .grid { display:grid; grid-template-columns: 1.2fr .8fr; gap:12px; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .section { display:none; }
    .section.active { display:block; }
    .qbox { border:1px solid var(--bd); border-radius:12px; padding:12px; margin-bottom:10px; }
    .qtitle { font-weight:800; margin-bottom:8px; }
    .choices { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width: 720px){ .choices{ grid-template-columns:1fr; } }
    .choice { border:1px solid var(--bd); border-radius:12px; padding:10px; cursor:pointer; user-select:none; }
    .choice.selected { background:#f2f2f2; border-color:#cfcfcf; }
    .pill { background:#eee; border-radius:999px; padding:6px 10px; font-size:12px; display:inline-block; }
    .note { border-left:3px solid #ddd; padding-left:10px; margin-top:10px; }
    .axis { border:1px solid var(--bd); border-radius:12px; padding:12px; margin-bottom:10px; }
    .axisHead { display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .axisName { font-weight:800; }
    .badge { background:#eee; border-radius:999px; padding:6px 10px; font-size:12px; }
    .levelRow { display:grid; grid-template-columns: 70px 1fr; gap:10px; margin-top:10px; }
    .lvl { font-weight:800; }
    .gate { display:flex; flex-direction:column; gap:8px; }
    label.chk { display:flex; gap:10px; align-items:flex-start; font-size:13px; line-height:1.4; cursor:pointer; }
    input[type="checkbox"]{ transform: translateY(2px); }
    .actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button { border:1px solid var(--bd); background:#fff; padding:10px 12px; border-radius:12px; cursor:pointer; }
    button:hover { background:#fafafa; }
    .small { font-size:12px; padding:8px 10px; border-radius:10px; }
    .rightCol { display:flex; flex-direction:column; gap:12px; }
    canvas { width:100%; height:auto; background:#fff; border:1px solid var(--bd); border-radius:14px; }
    .scores { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .scoreItem { border:1px solid var(--bd); border-radius:12px; padding:10px; }
    .scoreItem b { display:block; font-size:13px; }
    .scoreItem span { font-size:13px; color:var(--muted); }
    .kpi { display:flex; gap:10px; flex-wrap:wrap; }
    .kpi .box { border:1px solid var(--bd); border-radius:12px; padding:10px; min-width: 220px; }
    .kpi .box b { display:block; font-size:13px; }
    .kpi .box div { font-size:13px; color:var(--muted); margin-top:4px; }
    .hr { height:1px; background:var(--bd); margin:12px 0; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>PD診断：8タイプ判定＋能力6軸（レーダー重ね表示）</h1>
    <div class="muted">
      <span class="pill">タイプ判定：24問（強制選択ペア比較）</span>
      <span class="pill">能力判定：6軸 GATE方式</span>
      <span class="pill">平均ライン：Lv3</span>
    </div>
    <div class="note muted">
      外向き/内向きは <b>オープン（共有志向）↔ クローズ（自己完結）</b> として判定します（表示は短く、注釈で意味も併記）。
    </div>

    <div class="tabs">
      <button class="tabBtn active" data-tab="type">タイプ判定（24問）</button>
      <button class="tabBtn" data-tab="ability">能力判定（6軸）</button>
      <button class="tabBtn" data-tab="result">結果（チャート）</button>
    </div>
  </div>

  <div class="grid">
    <div>
      <!-- TYPE -->
      <div class="card section active" id="section-type">
        <h2>タイプ判定（24問）</h2>
        <div class="muted">
          各問、より近い方を選んでください（中立は無し）。<br/>
          <b>メイン</b>：8タイプ（例：王道ヤンキー）／ <b>サブ</b>：次点の系統（ヤンキー/オタク/職人/アーティスト）
        </div>
        <div class="hr"></div>
        <div id="typeQuestions"></div>
        <div class="actions">
          <button id="calcTypeBtn">タイプ判定</button>
          <button id="resetTypeBtn">タイプ回答リセット</button>
        </div>
      </div>

      <!-- ABILITY -->
      <div class="card section" id="section-ability">
        <h2>能力判定（6軸・GATE方式）</h2>
        <div class="muted">
          Lv1→Lv5の段階突破（GATE）です。<b>最低Lvは1</b>です。<br/>
          ※「一度できた」ではなく「<b>安定してできる</b>」場合のみチェックしてください。
        </div>
        <div class="hr"></div>
        <div id="axes"></div>
        <div class="actions">
          <button id="calcAbilityBtn">能力を算出</button>
          <button id="resetAbilityBtn">能力チェックをリセット</button>
        </div>
      </div>

      <!-- RESULT -->
      <div class="card section" id="section-result">
        <h2>結果</h2>
        <div class="kpi" id="kpi"></div>
        <div class="actions">
          <button id="recalcAllBtn">再計算（タイプ＋能力）</button>
          <button class="small" id="copyBtn">結果をコピー</button>
        </div>
        <div class="note muted">
          レーダーは <b>本人（実測）</b> と <b>タイプ典型値（テンプレ）</b> を重ねて表示します。<br/>
          テンプレ条件：③は全タイプLv3固定／④は職人のみLv4、他Lv3／テンプレはLv5不使用。
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="rightCol">
      <div class="card">
        <h2>レーダーチャート（重ね表示）</h2>
        <div class="muted" style="margin-bottom:8px;">
          実測（太線）＋ 典型テンプレ（点線）を重ねます。
        </div>
        <canvas id="radar" width="560" height="560"></canvas>
      </div>

      <div class="card">
        <h2>能力スコア（平均との差分）</h2>
        <div class="muted">差分は <b>(Lv - 3)</b> で表示します（例：Lv4 → +1、Lv2 → -1）。</div>
        <div class="hr"></div>
        <div class="scores" id="scoreList"></div>
      </div>
    </div>
  </div>
</div>

<script>
/** ========= 8タイプ定義 =========
 * 系統(family): yankee / otaku / shokunin / artist
 * 向き(openness): open / close  (オープン=共有志向, クローズ=自己完結)
 * 8タイプID: family + "_" + openness
 */
const TYPE_META = {
  yankee_open:  { name:"王道ヤンキー", family:"ヤンキー", openness:"オープン（共有）" },
  yankee_close: { name:"ハリボテヤンキー", family:"ヤンキー", openness:"クローズ（自己完結）" },
  otaku_open:   { name:"頼れるオタク", family:"オタク", openness:"オープン（共有）" },
  otaku_close:  { name:"こじらせオタク", family:"オタク", openness:"クローズ（自己完結）" },
  shokunin_open:{ name:"柔軟な職人", family:"職人", openness:"オープン（共有）" },
  shokunin_close:{name:"頑固な職人", family:"職人", openness:"クローズ（自己完結）" },
  artist_open:  { name:"ひらけたアーティスト", family:"アーティスト", openness:"オープン（共有）" },
  artist_close: { name:"自己完結型アーティスト", family:"アーティスト", openness:"クローズ（自己完結）" },
};

// tie-break: fixed family priority and within family open before close? (only used if everything else ties)
const FAMILY_ORDER = ["ヤンキー","オタク","職人","アーティスト"];
const TYPE_ORDER = ["yankee_open","yankee_close","otaku_open","otaku_close","shokunin_open","shokunin_close","artist_open","artist_close"];

/** ========= タイプ判定（24問・強制選択） =========
 * 仕様: Q6=B（ペア比較）
 * 各問は A/Bのうちどちらが近いかを選ぶ
 * スコアは8タイプに加点（=選んだ側が所属するタイプへ）
 * tie防止: 各問に重みweight（降順）を付与し、同点時は「大きい重みを獲得した方」を優先する辞書順比較
 */
const TYPE_QUESTIONS = [
  // 1-6: ヤンキー vs オタク（推進/突破 vs 分析/整理）× open/close混ぜ
  {id:1,  a:{text:"停滞したら、まず動いて突破口を作る（周囲も巻き込む）", type:"yankee_open"},
          b:{text:"停滞したら、論点を分解して原因を整理し共有する", type:"otaku_open"}},
  {id:2,  a:{text:"責任を背負って前に出るが、内心は不安でも強がる", type:"yankee_close"},
          b:{text:"自分の正しさを守るため、議論より整合性を優先しがち", type:"otaku_close"}},
  {id:3,  a:{text:"「まず進める」が基本。途中で軌道修正すればいい", type:"yankee_open"},
          b:{text:"「まず定義する」が基本。前提が揃ってから動きたい", type:"otaku_open"}},
  {id:4,  a:{text:"否定されると踏ん張るが、内側で消耗しやすい", type:"yankee_close"},
          b:{text:"否定されるとロジックで防御し、距離を取ることがある", type:"otaku_close"}},
  {id:5,  a:{text:"会議は短く。結論を出して走りながら揃える", type:"yankee_open"},
          b:{text:"会議は必要。論点・選択肢・根拠を揃えて決めたい", type:"otaku_open"}},
  {id:6,  a:{text:"弱みを見せず抱え込みがち。強がりで突っ走る", type:"yankee_close"},
          b:{text:"自分の論理の城にこもりがち。外部の言い分を遮断する", type:"otaku_close"}},

  // 7-12: 職人 vs アーティスト（品質/積み上げ vs 感性/違和感）× open/close
  {id:7,  a:{text:"指摘を材料にして品質を上げる。プロセスも共有する", type:"shokunin_open"},
          b:{text:"感性を外に出し、反応を混ぜながら方向性を育てる", type:"artist_open"}},
  {id:8,  a:{text:"自分の美意識が絶対。介入はノイズに感じやすい", type:"shokunin_close"},
          b:{text:"自分の宇宙で完結。共有や言語化を必須としない", type:"artist_close"}},
  {id:9,  a:{text:"再現性ある品質が大事。チームの完成度を底上げしたい", type:"shokunin_open"},
          b:{text:"新しい価値のタネが大事。空気や前提を揺らしたい", type:"artist_open"}},
  {id:10, a:{text:"品質は自分の中で決める。外部評価は後でいい", type:"shokunin_close"},
          b:{text:"意味は自分の中で完結。説明より“確信”を優先する", type:"artist_close"}},
  {id:11, a:{text:"制約下で成立させるのが腕。実装に落として強い", type:"shokunin_open"},
          b:{text:"制約より違和感。まず問いを立ててから現実を合わせる", type:"artist_open"}},
  {id:12, a:{text:"手を動かすが共有しない。完成形だけ出したい", type:"shokunin_close"},
          b:{text:"考えはあるが共有しない。見せる必要を感じない", type:"artist_close"}},

  // 13-18: ヤンキー vs 職人（推進 vs 品質）× open/close
  {id:13, a:{text:"スピード優先。迷ったら決めて前に進める", type:"yankee_open"},
          b:{text:"精度優先。曖昧なら詰めてから出したい", type:"shokunin_open"}},
  {id:14, a:{text:"強がってでも走る。止まる方が怖い", type:"yankee_close"},
          b:{text:"自分の基準を曲げない。妥協は怖い", type:"shokunin_close"}},
  {id:15, a:{text:"チームの温度を上げて巻き込むのが得意", type:"yankee_open"},
          b:{text:"成果物の品質で周囲を納得させるのが得意", type:"shokunin_open"}},
  {id:16, a:{text:"弱さを見せない。指摘されると内側で焦る", type:"yankee_close"},
          b:{text:"指摘されると介入に感じる。自分の領域を守りたい", type:"shokunin_close"}},
  {id:17, a:{text:"現場の詰まりは勢いで解消。とにかく前へ", type:"yankee_open"},
          b:{text:"現場の詰まりは手直しで解消。最後まで磨く", type:"shokunin_open"}},
  {id:18, a:{text:"共有が苦手で抱え込む。結果で示したい", type:"yankee_close"},
          b:{text:"プロセスを隠しがち。完成品で語りたい", type:"shokunin_close"}},

  // 19-24: オタク vs アーティスト（整理/前提 vs 価値/違和感）× open/close
  {id:19, a:{text:"違和感があっても、まず事実と構造を整理して共有する", type:"otaku_open"},
          b:{text:"違和感が起点。言語化前でも方向性を提示できる", type:"artist_open"}},
  {id:20, a:{text:"正しさを守るため、議論を閉じがちになることがある", type:"otaku_close"},
          b:{text:"確信があるため、説明を省きがちになることがある", type:"artist_close"}},
  {id:21, a:{text:"要件や前提を揃えると安心。そこから強い", type:"otaku_open"},
          b:{text:"要件より意味が先。そこが決まると強い", type:"artist_open"}},
  {id:22, a:{text:"論理の整合が崩れると受け入れにくい", type:"otaku_close"},
          b:{text:"自分の感覚が崩れると受け入れにくい", type:"artist_close"}},
  {id:23, a:{text:"合意形成は論点と根拠で進めたい", type:"otaku_open"},
          b:{text:"合意形成は共鳴と納得感で進めたい", type:"artist_open"}},
  {id:24, a:{text:"議論が荒れると距離を取り、内側で固め直す", type:"otaku_close"},
          b:{text:"議論が荒れると黙って内側で確信を固め直す", type:"artist_close"}},
];

// weights (descending) for tie-break
const WEIGHTS = TYPE_QUESTIONS.reduce((acc,q,i)=>{
  // high weight for earlier questions (lexicographic importance)
  acc[q.id] = 1000 - i; // simple strict ordering
  return acc;
}, {});

const typeState = {}; // questionId -> "a" or "b"

function renderTypeQuestions(){
  const root = document.getElementById("typeQuestions");
  root.innerHTML = "";
  TYPE_QUESTIONS.forEach(q=>{
    const box = document.createElement("div");
    box.className = "qbox";
    const title = document.createElement("div");
    title.className = "qtitle";
    title.textContent = `Q${q.id}`;
    box.appendChild(title);

    const choices = document.createElement("div");
    choices.className = "choices";

    const a = document.createElement("div");
    a.className = "choice" + (typeState[q.id]==="a" ? " selected" : "");
    a.innerHTML = q.a.text;
    a.addEventListener("click", ()=>{
      typeState[q.id]="a";
      renderTypeQuestions();
    });

    const b = document.createElement("div");
    b.className = "choice" + (typeState[q.id]==="b" ? " selected" : "");
    b.innerHTML = q.b.text;
    b.addEventListener("click", ()=>{
      typeState[q.id]="b";
      renderTypeQuestions();
    });

    choices.appendChild(a);
    choices.appendChild(b);
    box.appendChild(choices);
    root.appendChild(box);
  });
}

function computeType(){
  // Gather per-type picked weights for lexicographic tie-break
  const picked = {};
  TYPE_ORDER.forEach(t=> picked[t] = []);
  const familyScore = {"ヤンキー":0,"オタク":0,"職人":0,"アーティスト":0};

  // require all answered? We'll allow partial but warn.
  TYPE_QUESTIONS.forEach(q=>{
    const sel = typeState[q.id];
    if(!sel) return;
    const t = sel==="a" ? q.a.type : q.b.type;
    picked[t].push(WEIGHTS[q.id]);
    // family tally for sub-type
    const fam = TYPE_META[t].family;
    familyScore[fam] += 1;
  });

  // sort weights descending for lex compare
  TYPE_ORDER.forEach(t=> picked[t].sort((x,y)=>y-x));

  // choose main type by lexicographic compare on picked[t]
  function better(a,b){
    const A = picked[a], B = picked[b];
    const L = Math.max(A.length,B.length);
    for(let i=0;i<L;i++){
      const av = A[i] ?? -1;
      const bv = B[i] ?? -1;
      if(av !== bv) return av > bv ? a : b;
    }
    // tie: fallback to type order
    return TYPE_ORDER.indexOf(a) < TYPE_ORDER.indexOf(b) ? a : b;
  }

  let best = TYPE_ORDER[0];
  TYPE_ORDER.slice(1).forEach(t=> best = better(best,t));

  // sub type family = second-highest familyScore (excluding main family)
  const mainFamily = TYPE_META[best].family;
  const sortedFamilies = FAMILY_ORDER
    .map(f=>({f, v: familyScore[f]}))
    .sort((x,y)=> y.v - x.v || (FAMILY_ORDER.indexOf(x.f)-FAMILY_ORDER.indexOf(y.f)));

  const subFamily = sortedFamilies.find(x=> x.f !== mainFamily)?.f ?? mainFamily;

  // openness summary
  const openness = TYPE_META[best].openness;

  const answered = Object.keys(typeState).length;
  const total = TYPE_QUESTIONS.length;

  return { mainTypeId: best, mainFamily, subFamily, openness, answered, total, familyScore };
}

/** ========= 能力判定（6軸GATE） ========= */
const axes = [
  { key:"framing", name:"① 課題定義力", hint:"問い・目的・前提を整理し直す力",
    gates:[
      {lvl:1, items:["与件（要件）を自分の言葉で言い直せる","目的・制約・成功条件を最低限整理して共有できる"]},
      {lvl:2, items:["違和感や曖昧さを“論点”として言語化できる","スコープ（何をやらないか）を意識して話せる"]},
      {lvl:3, items:["『本当の課題はこれ』と再解釈して説明できる","優先順位や判断の前提を整理して合意を取りにいける"]},
      {lvl:4, items:["課題設定を置き換えた提案で方針に影響を与えた経験がある","上流に対して問いを立て直した経験がある"]},
      {lvl:5, items:["プロジェクトの起点となる問いを設計し周囲を動かした経験がある","問題設定の型（方法）を持っている"]},
    ]
  },
  { key:"concept", name:"② コンセプト力", hint:"意味・軸・一貫性を作る力",
    gates:[
      {lvl:1, items:["狙い（誰に何の価値）を短く言える","コンセプトが後付けにならないよう早い段階で置ける"]},
      {lvl:2, items:["コンセプトから要件へ落とし込みができる","迷ったときに戻れる“軸”を使える"]},
      {lvl:3, items:["コンセプトを判断基準としてレビューで使える","一貫性を維持できる"]},
      {lvl:4, items:["他人も同じ軸で判断できるよう共有・浸透させられる","複数要素を同一コンセプトで束ねられる"]},
      {lvl:5, items:["思想・世界観レベルで一貫性を作れる","ブランド視点でもコンセプトを設計できる"]},
    ]
  },
  { key:"quality", name:"③ 表現品質力", hint:"アウトプットの完成度・洗練度",
    gates:[
      {lvl:1, items:["重大な破綻がない","指示通りの成果物を期限内に出せる"]},
      {lvl:2, items:["修正を経て一定水準に到達できる","粗さ・ノイズを自分で減らせる"]},
      {lvl:3, items:["初稿で大きな修正が不要なことが多い","安定して『普通に良い』水準を出せる"]},
      {lvl:4, items:["無駄がなく洗練した仕上げができる","説明なしでも質が伝わると言われる"]},
      {lvl:5, items:["並べても見劣りしない完成度を継続的に出せる","表現の質が意思決定理由になったことがある"]},
    ]
  },
  { key:"implementation", name:"④ 実装理解力", hint:"制約・技術・現実性を踏まえる力",
    gates:[
      {lvl:1, items:["主要な制約を最低限意識して提案する","実装側と会話が成立する"]},
      {lvl:2, items:["制約を踏まえた代替案を用意できる","成立しない案を早めに見抜ける"]},
      {lvl:3, items:["制約内で成立する提案を安定して出せる","懸念を取り込み仕様に落とせる"]},
      {lvl:4, items:["最初から作れる設計として提案できる","実装側から信頼され相談される"]},
      {lvl:5, items:["開発の前進に直接貢献した経験がある","制約を味方にして価値を上げる提案ができる"]},
    ]
  },
  { key:"update", name:"⑤ 自己更新力", hint:"フィードバックを受け取り変える力",
    gates:[
      {lvl:1, items:["指摘を受けても感情と成果物を切り分けられる","言い訳より先に直すべき点を整理できる"]},
      {lvl:2, items:["外部だけでなく内部（上司/リーダー）の指摘も同様に受け止められる","指摘を要点化し次の行動に落とせる"]},
      {lvl:3, items:["反発があっても行動が変わる","同じ指摘を繰り返されにくい"]},
      {lvl:4, items:["判断基準を更新できる","自分からフィードバックを求める習慣がある"]},
      {lvl:5, items:["短期間で成長曲線を作れる","基準（やり方）を継続的に更新している"]},
    ]
  },
  { key:"alignment", name:"⑥ 合意形成力", hint:"共有し前に進める力",
    gates:[
      {lvl:1, items:["相手に伝わる形で説明できる","レビューで何を決めたいかを明確にできる"]},
      {lvl:2, items:["相手に合わせて言い換えできる","反対意見への対応ができる"]},
      {lvl:3, items:["止めない合意点を作れる","意思決定プロセスを理解して動ける"]},
      {lvl:4, items:["合意形成をやり切れる","意思決定を加速させた経験がある"]},
      {lvl:5, items:["周囲が自発的に動く状態を作れる","難しい合意形成でも納得感の高い結論へ導ける"]},
    ]
  },
];

const abilityState = {}; // abilityState[axisKey][lvl][idx] boolean

function initAbilityState(){
  axes.forEach(ax=>{
    abilityState[ax.key] = {};
    ax.gates.forEach(g=>{
      abilityState[ax.key][g.lvl] = new Array(g.items.length).fill(false);
    });
  });
}

function renderAxes(){
  const root = document.getElementById("axes");
  root.innerHTML="";
  axes.forEach(ax=>{
    const box=document.createElement("div");
    box.className="axis";
    const head=document.createElement("div");
    head.className="axisHead";
    head.innerHTML = `<div class="axisName">${ax.name}</div><div class="badge">${ax.hint}</div>`;
    box.appendChild(head);

    ax.gates.forEach(g=>{
      const row=document.createElement("div");
      row.className="levelRow";
      const lv=document.createElement("div");
      lv.className="lvl";
      lv.textContent = `Lv${g.lvl}`;
      row.appendChild(lv);

      const gate=document.createElement("div");
      gate.className="gate";

      g.items.forEach((text, idx)=>{
        const id=`${ax.key}_L${g.lvl}_${idx}`;
        const cb=document.createElement("input");
        cb.type="checkbox";
        cb.id=id;
        cb.checked = abilityState[ax.key][g.lvl][idx];
        cb.addEventListener("change", ()=> abilityState[ax.key][g.lvl][idx]=cb.checked);
        const lab=document.createElement("label");
        lab.className="chk";
        lab.htmlFor=id;
        const span=document.createElement("span");
        span.innerHTML=text;
        lab.appendChild(cb);
        lab.appendChild(span);
        gate.appendChild(lab);
      });

      row.appendChild(gate);
      box.appendChild(row);
    });

    root.appendChild(box);
  });
}

function levelForAxis(ax){
  let lvl = 1; // minimum Lv1 (per your request)
  for(const g of ax.gates){
    const all = g.items.every((_,i)=> abilityState[ax.key][g.lvl][i] === true);
    if(all) lvl = g.lvl;
    else break;
  }
  return lvl;
}

function computeAbility(){
  const res = {};
  axes.forEach(ax=> res[ax.key] = levelForAxis(ax));
  return res;
}

/** ========= 典型テンプレ（あなたの条件を反映） =========
 * 条件:
 *  - axis③(quality)=3 for all
 *  - axis④(implementation)=4 for shokunin_* only, otherwise 3
 *  - template uses no Lv5 (max 4)
 */
function templateForType(typeId){
  const family = TYPE_META[typeId].family;

  // Base templates (Lv1-Lv4) for ①②⑤⑥ only.
  // Derived from our earlier tendency and capped to 4.
  // axes keys: framing, concept, quality, implementation, update, alignment
  const base = {
    yankee_open:   {framing:2, concept:2, update:3, alignment:4},
    yankee_close:  {framing:2, concept:2, update:2, alignment:2},
    otaku_open:    {framing:4, concept:3, update:4, alignment:4},
    otaku_close:   {framing:3, concept:3, update:2, alignment:2},
    shokunin_open: {framing:3, concept:3, update:4, alignment:3},
    shokunin_close:{framing:2, concept:2, update:1, alignment:1},
    artist_open:   {framing:4, concept:4, update:4, alignment:3},
    artist_close:  {framing:4, concept:4, update:2, alignment:1},
  };

  const t = base[typeId] ?? {framing:3, concept:3, update:3, alignment:3};
  const quality = 3; // fixed
  const implementation = (family === "職人") ? 4 : 3;

  return {
    framing: t.framing,
    concept: t.concept,
    quality,
    implementation,
    update: t.update,
    alignment: t.alignment,
  };
}

/** ========= Radar chart (Canvas) =========
 * Draw 2 layers: measured + template.
 * Use grayscale (no flashy colors).
 */
function drawRadar(measured, template){
  const canvas = document.getElementById("radar");
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  const cx=w/2, cy=h/2;
  const maxR = Math.min(w,h)*0.38;
  const N = axes.length; // 6
  const maxLv = 5;

  const angle0 = -Math.PI/2;
  const pt = (i, r) => {
    const a = angle0 + (2*Math.PI*i)/N;
    return { x: cx + r*Math.cos(a), y: cy + r*Math.sin(a) };
  };

  // grid
  ctx.lineWidth=1;
  ctx.strokeStyle="#e6e6e6";
  for(let lv=1; lv<=maxLv; lv++){
    const r = (lv/maxLv)*maxR;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const p=pt(i,r);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath(); ctx.stroke();
  }

  // spokes
  ctx.strokeStyle="#ededed";
  for(let i=0;i<N;i++){
    const p=pt(i,maxR);
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(p.x,p.y); ctx.stroke();
  }

  // labels
  ctx.fillStyle="#333";
  ctx.font="13px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial, sans-serif";
  for(let i=0;i<N;i++){
    const p=pt(i,maxR*1.12);
    const label = axes[i].name.replace(/^\d+\s*/,"");
    const tw = ctx.measureText(label).width;
    let x=p.x, y=p.y;
    if(p.x < cx-5) x -= tw;
    if(Math.abs(p.x-cx) < 10) x -= tw/2;
    if(p.y < cy) y -= 6;
    ctx.fillText(label, x, y);
  }

  // avg line (Lv3)
  const avgR = (3/maxLv)*maxR;
  ctx.strokeStyle="#d8d8d8";
  ctx.setLineDash([6,4]);
  ctx.beginPath();
  for(let i=0;i<N;i++){
    const p=pt(i,avgR);
    if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.closePath(); ctx.stroke();
  ctx.setLineDash([]);

  function polygon(values, stroke, fill, dash, width){
    ctx.lineWidth = width;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    if(dash) ctx.setLineDash(dash); else ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const key = axes[i].key;
      const lv = Math.max(1, Math.min(maxLv, values[key] ?? 1));
      const r = (lv/maxLv)*maxR;
      const p = pt(i,r);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath();
    if(fill) ctx.fill();
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // template layer (dashed, lighter)
  if(template){
    polygon(template, "#888", "rgba(180,180,180,0.14)", [6,4], 2);
  }
  // measured layer (solid, darker)
  polygon(measured, "#333", "rgba(120,120,120,0.18)", null, 3);

  // legend
  ctx.fillStyle="#444";
  ctx.font="12px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial, sans-serif";
  ctx.fillText("実測（太線）", 14, 20);
  ctx.fillText("テンプレ（点線）", 14, 36);
}

function renderScores(measured){
  const root = document.getElementById("scoreList");
  root.innerHTML="";
  axes.forEach(ax=>{
    const lv = measured[ax.key] ?? 1;
    const diff = lv - 3;
    const sign = diff>0 ? `+${diff}` : `${diff}`;
    const item=document.createElement("div");
    item.className="scoreItem";
    item.innerHTML = `<b>${ax.name}</b><span>Lv${lv}（平均との差分 ${sign}）</span>`;
    root.appendChild(item);
  });
}

function renderKPI(typeRes, measured, template){
  const root = document.getElementById("kpi");
  root.innerHTML="";
  const main = TYPE_META[typeRes.mainTypeId]?.name ?? "未判定";
  const fam = typeRes.mainFamily ?? "-";
  const sub = typeRes.subFamily ?? "-";
  const open = typeRes.openness ?? "-";
  const answered = `${typeRes.answered}/${typeRes.total}`;

  const b1 = document.createElement("div");
  b1.className="box";
  b1.innerHTML = `<b>メインタイプ</b><div>${main}</div>`;
  const b2 = document.createElement("div");
  b2.className="box";
  b2.innerHTML = `<b>オープン/クローズ</b><div>${open}</div>`;
  const b3 = document.createElement("div");
  b3.className="box";
  b3.innerHTML = `<b>サブ（次点の系統）</b><div>${sub}</div>`;
  const b4 = document.createElement("div");
  b4.className="box";
  b4.innerHTML = `<b>回答状況</b><div>${answered}</div>`;

  root.appendChild(b1);
  root.appendChild(b2);
  root.appendChild(b3);
  root.appendChild(b4);
}

function updateAll(){
  const typeRes = computeType();
  const measured = computeAbility();
  const template = typeRes.mainTypeId ? templateForType(typeRes.mainTypeId) : null;

  drawRadar(measured, template);
  renderScores(measured);
  renderKPI(typeRes, measured, template);
  return {typeRes, measured, template};
}

/** ========= UI wiring ========= */
function showTab(tab){
  document.querySelectorAll(".tabBtn").forEach(b=> b.classList.toggle("active", b.dataset.tab===tab));
  document.querySelectorAll(".section").forEach(s=> s.classList.remove("active"));
  document.getElementById(`section-${tab}`).classList.add("active");
  // Always refresh chart when going to result
  if(tab==="result") updateAll();
}

document.querySelectorAll(".tabBtn").forEach(btn=>{
  btn.addEventListener("click", ()=> showTab(btn.dataset.tab));
});

// Buttons
document.getElementById("calcTypeBtn").addEventListener("click", ()=>{
  const res = computeType();
  if(res.answered < res.total){
    alert(`未回答があります（${res.answered}/${res.total}）。未回答のままでも暫定判定は可能ですが、精度のため全回答を推奨します。`);
  } else {
    alert("タイプ判定を更新しました。結果タブで確認できます。");
  }
});
document.getElementById("resetTypeBtn").addEventListener("click", ()=>{
  Object.keys(typeState).forEach(k=> delete typeState[k]);
  renderTypeQuestions();
});
document.getElementById("calcAbilityBtn").addEventListener("click", ()=>{
  alert("能力を算出しました。結果タブで確認できます。");
});
document.getElementById("resetAbilityBtn").addEventListener("click", ()=>{
  initAbilityState();
  renderAxes();
});
document.getElementById("recalcAllBtn").addEventListener("click", ()=> updateAll());

document.getElementById("copyBtn").addEventListener("click", async ()=>{
  const {typeRes, measured, template} = updateAll();
  const mainName = TYPE_META[typeRes.mainTypeId]?.name ?? "未判定";
  const linesA = axes.map(ax=> `${ax.name}: Lv${measured[ax.key] ?? 1}（差 ${((measured[ax.key] ?? 1)-3)>=0?'+':''}${(measured[ax.key] ?? 1)-3}）`);
  const linesT = template ? axes.map(ax=> `${ax.name}: Lv${template[ax.key]}`) : [];
  const text =
`【タイプ判定】
メイン: ${mainName}
向き: ${typeRes.openness}
サブ（次点系統）: ${typeRes.subFamily}
回答: ${typeRes.answered}/${typeRes.total}

【能力（実測）】
${linesA.join("\n")}

【典型テンプレ（重ね表示）】
${linesT.join("\n")}`;
  try{
    await navigator.clipboard.writeText(text);
    alert("結果をコピーしました。");
  }catch(e){
    alert("コピーに失敗しました（ブラウザ設定をご確認ください）。");
  }
});

/** ========= Init ========= */
renderTypeQuestions();
initAbilityState();
renderAxes();
updateAll();
</script>
</body>
</html>
